# Title

Syscalls

# Status

Accepted

# Context

**syscalls** are used to implement interfaces between applications running in **user mode** and privilege services running in **kernel mode**. Syscalls are implemented through an instruction which will trigger a dedicated **exception** (**ecall** on riscv for example). Their implementation share many mechanisms with the [exception](./adr-007.md) handling control flow.

One difference with other exceptions is that we need to pass information from user mode to kernel mode and vice versa. **linux** used to do this by pushing all information on the stack, a pointer is then passed through one register. This can be seen in [do_trap_ecall_u](https://elixir.bootlin.com/linux/latest/source/arch/riscv/kernel/traps.c#L313) and [syscall_handler](https://elixir.bootlin.com/linux/latest/source/arch/riscv/include/asm/syscall.h#L79). This allows great portability as it only use **one register** of the processor but this induced a lot of memory accesses through pushes and poppes to/from the stack. This implementation is also due to early architectures such as **x86** which only exposes one argument register.

**zephyr** uses a very similar implementation to linux as [is_user_syscall](https://github.com/zephyrproject-rtos/zephyr/blob/main/arch/riscv/core/isr.S#L411) does somes checks then [jumps](https://github.com/zephyrproject-rtos/zephyr/blob/main/arch/riscv/core/isr.S#L467) to the syscall registered in [_k_syscall_table](https://github.com/zephyrproject-rtos/zephyr/blob/main/include/zephyr/internal/syscall_handler.h#L25). One thing to notice is that **zephyr** uses the script [gen_syscall.py](https://github.com/zephyrproject-rtos/zephyr/blob/main/scripts/build/gen_syscalls.py) to initialize the syscall table.

**lk** also uses a similar approach in [riscv_exception_handler](https://github.com/littlekernel/lk/blob/master/arch/riscv/exceptions.c#L109) as it uses the **frame** argument: this is a pointer to the stack on which all information are saved.

These three examples give a good idea of how the syscall shall be handled when the exception is triggered. But some glue is needed to put arguments in registers and trigger the exception. [zircon](https://fuchsia.dev/fuchsia-src/concepts/kernel/life_of_a_syscall), through its documentation, describes how to do this. The figure below summerizes the process:

```C

              ┌─────────────────────────────────┐
              │ 1.Program:                      │ ──┐
              │                                 │   │
              │     zx_channel_create(...)      │   │
              │                                 │   │  hand-written
              │     return 0;                   │   │
              │                                 │ ──┘
 User mode    │                                 │
              │ 2.zx_channel_create:            │ ──┐
              │                                 │   │
              │     push args to registers      │   │  generated
              │                                 │   │
              │     move syscall number in eax  │   │  (architecture specific)
              │                                 │ ──┘
              │     syscall                     │
              └───────────────┬─────────────────┘
                              │
                              │ exception
                              │
              ┌───────────────▼────────────────┐
              │ 3._syscall_wrapper:            │  ──┐
              │                                │    │  generated
              │     find handler in table      │    │
              │                                │    │  (architecture specific)
              │     jump sys_channel_create    │  ──┘
kernel mode   │                                │
              │ 4.syscall implementation:      │  ──┐
              │                                │    │  hand-written
              │     sys_channel_create(...) {  │    │
              │         ...                    │  ──┘
              │     }                          │
              └────────────────────────────────┘
```
As seen in the figure, only the syscall implementation (**sys_channel_create**) is hand written. The whole glue is generated by the toolchain.

# Decision

When a syscall triggers the **_exception_handler**, a **_syscall_wrapper** defined in the **_exception_table** dispatches it through a second table called **_syscall_table**. This wrapper uses the **a[7]** register (fed by the **syscall entry**) to chose the right handler to call. This enables the system to use **7 registers** to exchange information with the kernel: this speeds up message passing compare to passing arguments on the stack.  

All arguments are passed through registers (**a[0-6]**). These registers are left unchanged throughout the flow, that's why **_exception_handler** and **_syscall_wrapper** are written in assembly. If not the compiler would update argument registers values due to function prototypes declaration. 

Syscall **prototypes** definition enables the compiler to feed the argument registers when calling the syscall. The same thing happens in the routine which handles the syscall, as its prototype enables the compiler to known in which registers it will find arguments.

The whole process is pretty similar to the one seen in **zircon** and is summarized below:

```C
 ┌──────────────────┐
 │  user_function() │
 └────────┬─────────┘
          │
          │ compiler moves arguments in
          │
          │ registers a0, a1, a2, a3
          │
          │ then calls ax_task_create()
          │
          │       ┌──────────────────┐
          └───────► ax_task_create() │
                  └────────┬─────────┘
                           │
                           │ copy the syscall number
                           │
                           │ in a7 and call ecall
                           │
                       ┌───▼───┐
                       │ ecall │
                       └───┬───┘
                           │              ┌───────────────┐     ┌───────────────────────────┐
                           └──────────────► _trap_handler │     │                           │
                                          └───────┬───────┘     │ _exception_vector_table   │
                                                  │             │                           │ get the syscall number from
                                                  │             │                           │
                                                  │             │  handle_page_fault        │ the a7 register and get the
                                                  │             │                           │                             ┌─────────────────┐
                                                  │             │  handle_load_access_fault │ corresponding handler from  │                 │
                                                  │             │                           │                             │ _syscall_table  │
                                                  │             │  ...                      │ the syscall table           │                 │
                                                  │             │                                                         │                 │
                                                  └─────────────►  _syscall_wrapper ──────────────────────────────────────►  task_create ─┐ │
                                                                │                                                         │               │ │
                                                                   ...                                                    │  task_yield   │ │
                                                                                                                          │               │ │
                                                                                                                          │  ...          │ │
                                                                                                                          │               │
                                                                                                                                          │
                                          ┌────────────────┐                                                                              │
                                          │ _ret_from_trap ◄──────────────────────────────────────────────────────────────────────────────┘
                                          └────────┬───────┘
                        ┌─────┐                    │                                                 as a[0-6] register have not been modified,
                        │ ret ◄────────────────────┘
                        └──┬──┘                                                                      ax_task_create() and task_create()
                           │
 ┌──────────────────┐      │                                                                         prototypes are identical
 │  user_function() ◄──────┘
 └──────────────────┘
```

As described above, **zircon** uses its build system to generate **zx_channel_create** syscall entry and **_syscall_wrapper** dispatcher. As opposite, **ax_task_create** and **syscall_wrapper** are hand-written but their behavior is similar. 

One difference is that **ax_task_create** does not need to feed argument registers as the compiler does it when the user program calls the **syscall entry**.

# Consequences

One optimization could be to add a code generator in the build system to automatically generate **syscall entries** and **_syscall_wrapper** glue for each supported architecture.