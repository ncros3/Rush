# Title

Exceptions management

# Status

Accepted

# Context

The kernel needs a way to handle exceptions. There are 2 types of exceptions: **synchronous** which are asserted by the program or the core itself and **asynchronous** which are asserted by **interrupts** externals to the core. 

A high-level mechanism is used which will dispatch exceptions to the dedicated handler: **interrupt_handler** or **exception_handler**.

In linux, this is implemented in the [handle_exception](https://elixir.bootlin.com/linux/latest/source/arch/riscv/kernel/entry.S#L85) routine. On **riscv**, this function is registered in **mtvec** and is called whenever an exception is asserted. Some interesting parts of the implementation can be seen here after:

```asm
SYM_CODE(handle_exception)
    ...
    csrr s4, CSR_CAUSE
	...
	la ra, ret_from_exception
	...
	bge s4, zero, 1f

	/* Handle interrupts */
	tail do_irq
1:
	/* Handle other exceptions */
	slli t0, s4, RISCV_LGPTR
	la t1, excp_vect_table
	la t2, excp_vect_table_end
	add t0, t1, t0
	/* Check if exception code lies within bounds */
	bgeu t0, t2, 1f
	REG_L t0, 0(t0)
	jr t0
1:
	tail do_trap_unknown
SYM_CODE_END(handle_exception)
```

When observing the code, it can be noticed that the register **mcause** saved in **s4** is used to dispatch interrupts and exceptions: **bge s4, zero, 1f** instruction jumps to **do_irq** if an interrupt triggered the handler. Otherwise, a dedicated **exception handler** is called. 

These handler addresses are registered in an array called **excp_vect_table**:

```asm
SYM_CODE_START(excp_vect_table)
	...
	RISCV_PTR do_trap_ecall_u /* system call */
	RISCV_PTR do_trap_ecall_s
	...
	RISCV_PTR do_trap_ecall_m
	...
	RISCV_PTR do_page_fault 
excp_vect_table_end:
SYM_CODE_END(excp_vect_table)
```

Each handler address is stored at an offset in the table. This offset is computed from the **mcause** register value then added to the table base address. This enables to compute the handler address which is stored in **t0** then **jr** instruction is used to jump into it.

If **mcause** value leads to an address which is not contained in the table, the code jumps to **do_trap_unknown**.

Eventually, if **mcause** value is **11** (which is equivalent to an **ecall**) for example, the **handle_exception** function will jump to **do_trap_ecall_m**.

One last thing to notice is the **ret_from_exception** routine. This function is called when an exception handler returns. It's loaded in **ra** register before the dispatch. To prevent the core to overwrite it when calling sub-routines, the **tail** instruction is used: the behaviour is similar to the **call** instruction but it doesn't update the **ra** value.

A pretty similar flow can be seen in **lk**, the [riscv_exception_entry](https://github.com/littlekernel/lk/blob/master/arch/riscv/asm.S#L139) calls [riscv_exception_handler](https://github.com/littlekernel/lk/blob/master/arch/riscv/exceptions.c#L110C21-L110C21) which will dispatch the event to the dedicated handler. A part of the routine can be seen here after: 

```C
void riscv_exception_handler(long cause, ulong epc, struct riscv_short_iframe *frame, bool kernel) {
    ...
    // top bit of the cause register determines if it's an interrupt or not
    if (cause < 0) {
        switch (cause & LONG_MAX) {
            case RISCV_INTERRUPT_XSWI: // machine software interrupt
                ret = riscv_software_exception();
                break;
            case RISCV_INTERRUPT_XTIM: // machine timer interrupt
                ret = riscv_timer_exception();
                break;
            case RISCV_INTERRUPT_XEXT: // machine external interrupt
                ret = riscv_platform_irq();
                break;
            default:
                fatal_exception(cause, epc, frame, kernel);
        }
    } else {
        // all synchronous traps go here
        switch (cause) {
            case RISCV_EXCEPTION_ENV_CALL_U_MODE: // ecall from user mode
                riscv_syscall_handler(frame);
                break;
            default:
                fatal_exception(cause, epc, frame, kernel);
        }
    }
    ...
}
```
This routine is written in C when all the work is done in assembly in linux. One function is defined by interrupt or exception type. This is very similar to the **zircon** design (as zircon is a fork of lk) but more handlers are defined in [riscv64_exception_handler](https://cs.opensource.google/fuchsia/fuchsia/+/main:zircon/kernel/arch/riscv64/exceptions_c.cc;l=259) to manage exceptions. This handler is also called by [riscv64_exception_entry](https://cs.opensource.google/fuchsia/fuchsia/+/main:zircon/kernel/arch/riscv64/exceptions.S;l=231) as in **lk**.

# Decision

The final implementation is heavily inspired by the linux one. **_trap_handler** dispatches the exception to the right handler. This routine is very similar to **handle_exception** described in the previous section.

The design of the **_exception_vector_table** is very speficic as it allows the **mcause** value to be used to compute the offset in the table. Indeed, **each handler is placed at a multiple of 0x10**. This allows to compute each address in the array as follows: **mcause * 0x10 + table_base_address**. This is what this code does:

```asm
    slli    t0, t0, RISCV_PTR_LENGTH
    la      t1, _exception_vector_table
    ...
    add     t0, t1, t0
```

Eventually, when an exception occurs, it passes through the following path:

```C
                    Task_A

            ┌─────────────────────┐
            │  previous_function  │
            └──────────┬──────────┘
                       │
                ┌──    │
                │      │
                │ ┌────▼────┐
                │ │  Ecall  │
                │ └────┬────┘
                │      │
                │      │      ┌───────────────┐    ┌─────────────────────────────┐
                │      └──────► _trap_handler │    │                             │
                │             └───────┬───────┘    │ _exception_vector_table     │
                │                     │            │                             │
                │                     │            │                             │
                │                     │            │  handle_page_fault          │
                │                     │            │                             │
  task_yield()  │                     │            │  handle_load_access_fault   │
                │                     │            │                             │
                │                     │            │  ...                        │
                │                     │            │                             │
                │                     └────────────►  handle_syscall             │
                │                                  │                             │
                │                                  │  ...   │                    │
                │            ┌────────────────┐    │        │                    │
                │            │ _ret_from_trap ◄────┼────────┘                    │
                │            └────────┬───────┘    │                             │
                │  ┌─────┐            │            └─────────────────────────────┘
                │  │ ret ◄────────────┘
                │  └──┬──┘
                │     │
                └──   │
                      │
              ┌───────▼─────────┐
              │  next_function  │
              └─────────────────┘
```
In this example, the **task_yield()** function which is a **syscall** is used to call the **ecall** instruction. This event triggers the **_trap_handler**. 

# Consequences

The implementation allows **portability** as all exceptions trigger **_trap_handler** which will dispatch the event to the right handler. A more optimized solution might use the **hardware dispatch mechanism** available in **riscv architecture** (see the **vectored mode** described in RISCV Privileged ISA, 3.1.7).