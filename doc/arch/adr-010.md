# Title

Interruptions

# Status

Proposed

# Context

restore MEPC for interruptions

save and restore full context

- interrupts are disabled when a trap is triggered. See [RISCV ISA chapter 3.1.6.1](https://five-embeddev.com/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine-status-registers-mstatus-and-mstatush). So we do not need to disable interrupts at the beginning of the trap handler.

- 

# Decision

Here are **key features** of the interrupt mechanism:
- **deffered interrupt**: interrupts are handled in two phases, **critical** and **deffered** in a very similar way as [linux](https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html) does. In the **critical** phase, the kernel only aknowledges the interrupt and creates a task to handle it. The **deffered** phase is handled by a dedicated task which acts as a **driver**. This task has been registered by the kernel to be called when an interrupt occurs through the syscall **ax_interrupt_request()**.

```C                                                                  
     IT event                             critical phase                          deffered phase  
                       ┌───────────────────────────────────────────────────┐    ┌────────────────┐
       │               │                                                   │    │                │
┌──────▼───────┐         ┌───────────────────┐          ┌───────────────┐         ┌─────────────┐ 
│ trap_handler ├─────────►  handle_interrupt ├──────────► task_wakeup() ├─────────► driver task │ 
└──────────────┘         └───────────────────┘          └───────────────┘         └─────────────┘ 
                         get the task which is       switch to the driver task                    
                        registered in isr_table                                                                                     
```
- **no nested interrupt**: the interrupt routine cannot be interrupted, only exceptions can. This is why **critical** interrupt routine is very minimal (it only acknowledges the interrupt and wakes up the driver task): it has to be as short as possible to not degrade real-time performance.

```C                                                                  
                                       syscall    IT                              IT       IT              
               IT event                 event    event                           event    event            
                                                                                                           
 user mode        │          ▲            │                            ▲          │        │         ▲     
                  │          │            │                            │          │        │         │     
         ─────────┼──────────┼────────────┼────────────────────────────┼──────────┼────────┼─────────┼──   
                  │          │            │                            │          │        │         │     
kernel mode       │      ┌───┴──┐         │                         ┌──┴───┐      │        ▼      ┌──┴───┐ 
                  └──────► mret │         └───────►          ┌──────► mret │      └───────────────► mret │ 
                         └──────┘                 │          │      └──────┘                      └──────┘ 
                                                  │       ┌──┴───┐                                         
                                                  └───────► mret │                                         
                                                          └──────┘                                         
                                        │                                   │    │                        │
                                        └───────────────────────────────────┘    └────────────────────────┘
                                                  IT during a syscall                  IT during an IT     
```
- **full context save and restore**: caller-saved registers are saved at the beginning of the trap handler as interrupts can preempt an exception. Kernel has to be able to resume exception execution at the end of the interrupt handling.
- **no dedicated interrupt stack**: **critical** interrupt routine runs in the task context which was used by the core when the interrupt occured. Once again, as the **critical** interrupt routine is very short, the risk of a stack overflow is minimal.


The full control flow of **interrupt handling** is described here after:
```C
                      │                                                             
     user mode        │        kernel mode                                          
                      │                                                             
                      │                                                             
  ┌──────────────┐    │                                                             
  │  user_task() │    │                                                             
  └──────────────┘    │                                                             
                      │     ┌───────────────┐                                       
         ─────────────┼─────► _trap_handler │                                       
 an IT event occurs   │     └───────┬───────┘                                       
                      │             │                                               
                      │             │                                               
                      │  ┌──────────▼──────────┐  save caller registes on the stack 
                      │  │ save caller context │  as user_task() have to be resumed 
                      │  └──────────┬──────────┘                                    
                      │             │                                               
                      │             │                                               
                      │    ┌────────▼─────────┐                                     
                      │    │ handle_interrupt │ get the interrupt handler           
                      │    └────────┬─────────┘      from isr_table                 
                      │             │                                               
                      │             │                                               
                      │      ┌──────▼───────┐  add the interrupt handler in the run 
                      │      │ task_wakeup  │  queue and run the scheduler          
                      │      └──────┬───────┘                                       
                      │             │                                               
                      │             │                                               
                      │ ┌───────────▼─────────────┐                                 
                      │ │  restore caller context │                                 
                      │ └───────────┬─────────────┘                                 
                      │             │                                               
                      │             │                                               
                      │     ┌───────▼────────┐                                      
          ┌───────────┼─────┤ _ret_from_trap │                                      
          │           │     └────────────────┘                                      
          │           │                                                             
  ┌───────┴───────┐   │                                                             
  │ driver_task() │   │                                                             
  └───────────────┘   │                                                             
```

The **driver_task** is the **deffered interrupt routine** described in the previous section. It is threated as any other **task** but it's designed to have a **high priority** such as it is **immediatly resumed when the context switch occurs in task_wakeup()**.

The **isr_table** is used to register all **interrupts handlers** (or **driver tasks**). Two **syscalls** are used to request and release interrupts from a user task:
- **ax_interrupt_request**: enables the required interrupt and save the task in the **isr_table**
- **ax_interrupt_release**: disables the required interrupt and release the corresponding handler in the **isr_table**.

# Consequences

